// 
//  Copyright 2022 Sergey Khabarov, sergeykhbr@gmail.com
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
// 
#pragma once

#include <systemc.h>
#include "../ambalib/types_dma.h"
#include "../ambalib/types_pnp.h"
#include "../ambalib/types_amba.h"
#include "pcie_cfg.h"
#include "../cdc/cdc_afifo.h"
#include "pcie_io_ep.h"

namespace debugger {

SC_MODULE(pcie_dma) {
 public:
    sc_in<bool> i_nrst;                                     // System Reset: active LOW
    sc_in<bool> i_clk;                                      // System bus clock
    sc_in<bool> i_pcie_phy_clk;                             // PCIE clock generated by end-point
    // PCIE EP - DMA engine interface
    sc_in<sc_uint<16>> i_pcie_completer_id;                 // Bus, Device, Function
    sc_out<sc_uint<4>> o_dma_state;                         // State machine debug output, connected to APB controller
    sc_in<pcie_dma64_in_type> i_pcie_dmai;                  // PCIE-EP to system DMA requests
    sc_out<pcie_dma64_out_type> o_pcie_dmao;                // System DMA responds to PCIE EP
    // DMA engine interface - System on Chip interface
    sc_out<dev_config_type> o_xmst_cfg;                     // PCIE DMA master interface descriptor
    sc_in<axi4_master_in_type> i_xmsti;
    sc_out<axi4_master_out_type> o_xmsto;
    // Debug signals:
    sc_out<pcie_dma64_in_type> o_dbg_pcie_dmai;

    void comb();

    pcie_dma(sc_module_name name);
    virtual ~pcie_dma();

    void generateVCD(sc_trace_file *i_vcd, sc_trace_file *o_vcd);

 private:
    // 
    static const int C_DATA_WIDTH = 64;
    static const int KEEP_WIDTH = (C_DATA_WIDTH / 8);
    // 
    static const int REQ_FIFO_WIDTH = (7  // bar_hit
            + 1  // ecrc_err
            + 1  // err_fwd
            + 1  // last
            + 8  // strob
            + 64  // data
    );
    static const int RESP_FIFO_WIDTH = (1  // last
            + 8  // strob
            + 64  // data
    );

    sc_signal<bool> w_pcie_dmai_valid;
    sc_signal<bool> w_pcie_dmai_ready;
    sc_signal<sc_biguint<REQ_FIFO_WIDTH>> wb_reqfifo_payload_i;
    sc_signal<sc_biguint<REQ_FIFO_WIDTH>> wb_reqfifo_payload_o;
    sc_signal<bool> w_reqfifo_wready;
    sc_signal<bool> w_reqfifo_rvalid;
    sc_signal<bool> w_reqfifo_rd;
    sc_signal<sc_biguint<RESP_FIFO_WIDTH>> wb_respfifo_payload_i;
    sc_signal<sc_biguint<RESP_FIFO_WIDTH>> wb_respfifo_payload_o;
    sc_signal<bool> w_respfifo_wready;
    sc_signal<bool> w_respfifo_rvalid;
    sc_signal<bool> w_respfifo_wr;
    sc_signal<sc_uint<9>> wb_m_axis_rx_tuser;
    sc_signal<bool> w_m_axis_rx_tlast;
    sc_signal<sc_uint<KEEP_WIDTH>> wb_m_axis_rx_tkeep;
    sc_signal<sc_uint<C_DATA_WIDTH>> wb_m_axis_rx_tdata;
    sc_signal<bool> w_s_axis_tx_tlast;
    sc_signal<sc_uint<KEEP_WIDTH>> wb_s_axis_tx_tkeep;
    sc_signal<sc_uint<C_DATA_WIDTH>> wb_s_axis_tx_tdata;
    sc_signal<bool> w_tx_src_dsc;
    sc_signal<bool> w_req_compl;
    sc_signal<bool> w_compl_done;

    cdc_afifo<CFG_PCIE_DMAFIFO_DEPTH, REQ_FIFO_WIDTH> *reqfifo;
    cdc_afifo<CFG_PCIE_DMAFIFO_DEPTH, RESP_FIFO_WIDTH> *respfifo;
    pcie_io_ep<C_DATA_WIDTH, KEEP_WIDTH> *PIO_EP_inst;

};

}  // namespace debugger

